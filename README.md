# Mission-Food-Chain
## Mission Senario

[지난 5월, 중남미 카리브해의 한 섬에서 물고기 비가 내렸다.](https://www.ytn.co.kr/_ln/0134_202505081611105791) 김난슬씨는 이 뉴스를 보고 문득 자신의 앞마당에 있는 연못에 물고기 비가 내린다면 그 물고기가 얼마나 살 수 있을지 궁금해져 이를 시뮬레이션하는 프로그램을 개발하고자 한다.

## Mission Overview

연못에 있는 물고기의 생존기간을 계산하는 프로그램을 개발한다. 연못은 물고기 비로 내린 물고기들로만 구성된다. 각 물고기는 먹이사슬에 따라 하루에 한 번만 먹이를 먹으며 먹이를 먹지 못한 개체는 죽는다. 연못에 떨어질 물고기들 각각의 종류와 마리수를 입력하면 마지막까지 남는 물고기가 생존한 기간을 출력한다.

## Mission Goals

- Collection API와 Stream API를 이해하고 적절히 활용한다.
- 적절한 알고리즘을 활용하여 프로그램을 구성한다.
- 추상화 및 의존성 분리 등을 통해 객체지향적으로 프로그램을 설계한다.
- 유지보수성과 가독성을 고려하여 코드를 작성한다.

## Study Documents

- https://velog.io/@hwsa1004/Java-MVC-%ED%8C%A8%ED%84%B4
- https://www.youtube.com/watch?v=Yzx-z6kCD2A
- https://hsc-tech.tistory.com/11
- https://devuna.tistory.com/32
- https://mangkyu.tistory.com/112
- https://velog.io/@chaerim1001/Java-Collection-%EC%A0%95%EB%A6%AC

## Mission Guide

1. [미션 저장소](https://github.com/allrounder-backend/mission-shoppingcart)를 Fork 한다.
2. Folk 한 레포의 main 브랜치에서 미션을 구현한다.
3. 구현이 끝난 후 미션 저장소에 PR을 보낸다.

## Feature Requirements Details

일반적으로 물고기들은 먹이사슬의 바로 아래 영양 단계의 물고기만 잡아먹는다. 아래 예시에서 고등어(영양단계 : 3)는 멸치, 정어리, 빙어(영양 단계 : 2)를 잡아먹을 수 있다고 가정한다. 플랑크톤은 생존 날자 계산에서 배제된다. id가 낮은 순으로 먹이를 먹는다.

### 어류 목록

| id | 이름 | 영양 단계 |
| --- | --- | --- |
| 1 | 플랑크톤 | 1 |
| 2 | 멸치 | 2 |
| 3 | 정어리 | 2 |
| 4 | 빙어 | 2 |
| 5 | 고등어 | 3 |
| 6 | 전갱이 | 3 |
| 7 | 꽁치 | 3 |
| 8 | 삼치 | 4 |
| 9 | 참치 | 4 |
| 10 | 방어 | 4 |
| 11 | 황새치 | 5 |
| 12 | 상어 | 5 |

※ 영양 단계는 먹이 사슬에서 생물이 차지하는 포식자 위치를 의미한다

ex) 물고기 비로 플랑크톤 10마리, 정어리 3마리, 고등어 2마리가 떨여졌다면

```bash
물고기 비로 내릴 물고기를 입력해주세요. (ex. [정어리-5],[고등어-2])
> [플랑크톤-100],[정어리-3],[고등어-2]
3일간 생존했습니다. 
```

- 세부 과정
    - 첫째날
        - 정어리 3마리가 플랑크톤 3마리를 먹음
        - 고등어 2마리가 정어리 2마리를 먹음
        - → 플랑크톤 97마리, 정어리 1마리, 고등어 2마리 생존
    - 둘째날
        - 정어리 1마리가 플랑크톤 1마리를 먹음
        - 고등어 1마리가 정어리 1마리를 먹음
        - 고등어 1마리가 먹이를 먹지 못해 죽음
        - → 플랑크톤 96마리, 고등어 1마리 생존
    - 셋째날
        - 고등어 1마리가 먹이를 먹지 못해 죽음
        - 플랑크톤 96마리 생존
        - → 결과적으로 3일차까지 생존 (플랑크톤은 생존 날자 계산에서 배제됨)

(응용) 각 물고기는 `식성` 이 존재한다. 먹이를 먹는 우선수위는 먹이사슬의 id 순(오름차순)이다. 먹이는 먹이사슬 내에서만 먹을 수 있다.

### 먹이사슬 관계

| id | 포식자 id | 피식자 id |
| --- | --- | --- |
| 1 | 2 | 1 |
| 2 | 3 | 1 |
| 3 | 4 | 1 |
| 4 | 5 | 2 |
| 5 | 5 | 3 |
| 6 | 6 | 3 |
| 7 | 7 | 2 |
| 8 | 7 | 4 |
| 9 | 8 | 5 |
| 10 | 8 | 6 |
| 11 | 9 | 5 |
| 12 | 9 | 6 |
| 13 | 9 | 7 |
| 14 | 10 | 6 |
| 15 | 10 | 7 |
| 16 | 11 | 8 |
| 17 | 11 | 10 |
| 18 | 12 | 9 |
| 19 | 12 | 10 |

포식자 id와 피식자 id는 어류 목록의 id와 동일하다.

![image.png](attachment:7154e6e5-e29c-493d-92fa-cc102071f218:image.png)

ex) 물고기 비로 플랑크톤 15마리, 정어리 3마리, 멸치 3마리, 꽁치 2마리가 떨여졌다면

```bash
물고기 비로 내릴 물고기를 입력해주세요. (ex. [정어리-5],[고등어-2])
> [플랑크톤-15],[정어리-3],[멸치-3],[꽁치-2]
5일간 생존했습니다. 
```

- 세부 과정
    - 첫째날
        - 정어리 3마리가 플랑크톤 3마리를 먹음
        - 멸치 3마리가 플랑크톤 3마리를 먹음
        - 꽁치 2마리가 멸치 2마리를 먹음 (꽁치는 멸치와 빙어만 먹음)
        - → 플랑크톤 9마리, 정어리 3마리, 멸치 1마리, 꽁치 1마리 생존
    - 둘째날
        - 정어리 3마리가 플랑크톤 3마리를 먹음
        - 멸치 1마리가 플랑크톤 1마리를 먹음
        - 꽁치 1마리가 멸치 1마리를 먹음
        - 꽁치 1마리가 먹이를 먹지 못해 죽음
        - → 플랑크톤 5마리, 정어리 3마리, 꽁치 1마리 생존
    - 셋째날
        - 정어리 3마리가 플랑크톤 3마리를 먹음
        - 꽁치 1마리가 먹이를 먹지 못해 죽음
        - → 플랑크톤 2마리, 정어리 3마리 생존
    - 넷째날
        - 정어리 2마리가 플랑크톤 2마리를 먹음
        - 정어리 1마리가 먹이를 먹지 못해 죽음
        - → 정어리 2마리 생존
    - 다섯째날
        - 정어리 2마리가 먹이를 먹지 못해 죽음
        - → 결과적으로 5일차까지 생존

(심화) 물고기는 id 순서대로 먹이를 먹지 않고 임의의 순서로 먹이를 먹을 때 가능한 최대 생존 기간을 출력한다.

ex) 물고기 비로 삼치 1마리, 고등어 1마리, 멸치 1마리, 플랑크톤 3마리가 떨어졌다면

```bash
물고기 비로 내릴 물고기를 입력해주세요. (ex. [정어리-5],[고등어-2])
> [삼치-1],[고등어-1],[멸치-1],[플랑크톤-3]
4일간 생존했습니다. 
```

- 세부 과정
    - 첫째날
        - 삼치 1마리가 고등어 1마리를 먹음 (임의의 순서)
        - 멸치 1마리가 플랑크톤 1마리를 먹음
        - → 멸치 1마리, 플랑크톤 2마리 생존
    - 둘째날
        - 멸치 1마리가 플랑크톤 1마리를 먹음
        - → 멸치 1마리, 플랑크톤 1마리 생존
    - 셋째날
        - 멸치 1마리가 플랑크톤 1마리를 먹음
        - → 멸치 1마리 생존
    - 넷째날
        - 멸치 1마리가 먹이를 먹지 못해 죽음
        - → 결과적으로 4일차까지 생존

  ※ 만약 임의의 순서가 아니었다면 멸치가 플랑크톤을 먹고 고등어가 멸치를 먹고 삼치가 고등어를 먹어서 2일차까지 생존했을 것이다.


### Exception Handling

다음과 같은 상황에서는 예외를 발생시켜 프로그램을 종료한다.

- 어류 목록에 없는 어류를 입력됨.
- 입력 양식이 틀린 응답이 입력됨.
- 너무 많은 수량이 입력되어 계산이 불가능함.
- …

```bash
물고기 비로 내릴 물고기를 입력해주세요. (ex. [정어리-5],[고등어-2])
> [갸라도스-1]

IllegalArgumentException : 어류 목록에 없는 어류가 입력되었습니다. 
```

기능 명세 및 테스트케이스에 정의되지 않은 예외적 상황은 자의적으로 판단하되 예외를 발생시킬 경우 그 사유를 명확하게 적시하며 프로그램을 종료시킨다.

## Programming Requirements Details

- 개발환경은 JDK 21을 사용한다.
- 프로그램 실행의 시작점은 `Application`의 `main()`이다.
- `build.gradle` 파일을 변경할 수 없고, 외부 라이브러리를 사용하지 않는다.
- 프로그램 종료 시 `System.exit()`를 호출하지 않는다.
- 구글 스타일 가이드를 준수하며 코드를 작성한다.

  https://google.github.io/styleguide/javaguide.html, 한국어 번역 https://newwisdom.tistory.com/m/96

    - 4.2 블럭 들여쓰기: +4 스페이스
        - 새 블록 또는 블록과 유사한 구조(block-like construct)가 열릴 때마다 들여쓰기가 네 칸씩 증가합니다. 블록이 끝나면 들여쓰기는 이전 들여쓰기 단계로 돌아갑니다. 들여쓰기 단계는 블록 전체의 코드와
          주석 모두에 적용됩니다.
    - 4.4 열 제한: 120
        - Java 코드의 열 제한은 120자입니다. "문자"는 유니코드 코드 포인트를 의미합니다.
    - 4.5.2 들여쓰기 지속은 최소 +8 스페이스
        - 줄 바꿈 시 그 다음 줄은 원래 줄에서 +8 이상 들여씁니다.
    - 4.6.1 수직 빈 줄
        - ...
          빈 줄은 가독성을 향상시키기 위해서라면 어디든(예를 들면 논리적으로 코드를 구분하기 위해 문장 사이) 사용 될 수 있습니다. 클래스의 첫 번째 멤버나 초기화(initializer) 또는 마지막 멤버 또는 초기화(
          initializer) 뒤의 빈 줄은 권장되지도 비권장하지도 않습니다.

          > 클래스의 첫 번째 멤버나 초기화(initializer) 앞에 있는 빈줄을 강제하지 않습니다.
          >

          ...

          변수명, 함수명도 컨벤션이다.

- 입력은 `api` 의 `Console.readline()` 을 활용한다.
- 테스트는 `api` 의 `TestEnvironment` 를 활용한다.
    - `TestEnvironment` 의 `runMain` 메서드에 실행할 내용을 구현한다.
    - `@Test` 의 `run()` 의 파라미터로 mocking할 입력들을 넣는다.
    - `@Test` 안에 있는 `output()` 은 출력 결과를 낚아챈다.
